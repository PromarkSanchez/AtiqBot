"""implement_core_config_models_and_refactor_context

Revision ID: d54b71c4a036
Revises: 
Create Date: 2025-05-26 00:33:03.525832

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = 'd54b71c4a036'
down_revision: Union[str, None] = None # Asumiendo que esta es la primera migración con estos cambios
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - with manual adjustments ###

    # --- PASO 0: Modificaciones a chat_message_history_v2 (independientes) ---
    op.alter_column('chat_message_history_v2', 'session_id',
               existing_type=sa.TEXT(),
               type_=sa.String(length=255),
               nullable=False)
    op.alter_column('chat_message_history_v2', 'message',
               existing_type=sa.TEXT(),
               type_=sa.JSON(), # En PostgreSQL, esto suele ser JSONB por defecto con SQLAlchemy
               nullable=False,
               postgresql_using='message::jsonb' # Usar ::jsonb si el tipo es JSONB, o ::json si es JSON
               ) # Asegúrate que el tipo final sea el que usa tu modelo SQLAlchemy ChatMessageHistoryV2
    op.create_index(op.f('ix_chat_message_history_v2_session_id'), 'chat_message_history_v2', ['session_id'], unique=False)

    # --- PASO 1: Preparar para el cambio de app_users -> app_user ---
    # Eliminar la Foreign Key de user_role_association que apunta a la antigua 'app_users'.
    # Usamos el nombre de la constraint que dio el error en el traceback.
    try:
        op.drop_constraint('user_role_association_app_user_id_fkey', 'user_role_association', type_='foreignkey')
    except Exception as e:
        print(f"INFO: Constraint 'user_role_association_app_user_id_fkey' no encontrada o ya eliminada. Error: {e}")

    # --- PASO 2: Eliminar la antigua tabla 'app_users' y sus índices ---
    op.drop_index(op.f('ix_app_users_email'), table_name='app_users', if_exists=True)
    op.drop_index(op.f('ix_app_users_id'), table_name='app_users', if_exists=True)
    op.drop_index(op.f('ix_app_users_username_ad'), table_name='app_users', if_exists=True)
    op.drop_table('app_users', if_exists=True)

    # ====> PASO 3: Limpiar la tabla user_role_association <====
    # Esto es porque la nueva FK a 'app_user' (que se creará vacía) fallará
    # si user_role_association tiene app_user_ids antiguos que ya no existen.
    op.execute('DELETE FROM user_role_association;')

    # --- PASO 4: Crear TODAS las nuevas tablas (incluyendo la nueva 'app_user') ---
    op.create_table('app_user',
        sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
        sa.Column('username_ad', sa.String(length=255), nullable=False, comment='DNI del usuario, usado como identificador de AD'),
        sa.Column('email', sa.String(length=255), nullable=True, comment='Email, idealmente obtenido de AD'),
        sa.Column('full_name', sa.String(length=255), nullable=True, comment='Nombre completo, idealmente obtenido de AD'),
        sa.Column('is_active_local', sa.Boolean(), server_default=sa.true(), nullable=False, comment='Si el usuario está activo en este sistema'),
        sa.Column('mfa_secret_encrypted', sa.String(length=512), nullable=True, comment='Secreto TOTP encriptado (con Fernet)'),
        sa.Column('mfa_enabled', sa.Boolean(), server_default=sa.false(), nullable=False, comment='Indica si MFA está habilitado para este usuario'),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), onupdate=sa.text('now()'), nullable=False),
        sa.PrimaryKeyConstraint('id', name=op.f('pk_app_user'))
    )
    op.create_index(op.f('ix_app_user_email'), 'app_user', ['email'], unique=True)
    op.create_index(op.f('ix_app_user_id'), 'app_user', ['id'], unique=False)
    op.create_index(op.f('ix_app_user_username_ad'), 'app_user', ['username_ad'], unique=True)

    op.create_table('human_agent_groups',
        sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
        sa.Column('name', sa.String(length=100), nullable=False, comment="Nombre del grupo/equipo de agentes humanos"),
        sa.Column('description', sa.Text(), nullable=True, comment='Descripción del propósito del grupo.'),
        sa.Column('is_active', sa.Boolean(), server_default=sa.true(), nullable=False, comment='Si el grupo está activo'),
        sa.Column('routing_config_json', sa.JSON(), nullable=True, comment='Configuración para el enrutamiento de chats'),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), onupdate=sa.text('now()'), nullable=False),
        sa.PrimaryKeyConstraint('id', name=op.f('pk_human_agent_groups')),
        sa.UniqueConstraint('name', name=op.f('uq_human_agent_groups_name'))
    )
    op.create_index(op.f('ix_human_agent_groups_id'), 'human_agent_groups', ['id'], unique=False)

    op.create_table('human_agents',
        sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
        sa.Column('full_name', sa.String(length=150), nullable=False, comment='Nombre completo del agente humano.'),
        sa.Column('email', sa.String(length=255), nullable=False, comment='Email del agente'),
        sa.Column('teams_id', sa.String(length=255), nullable=True, comment='ID de usuario de Microsoft Teams'),
        sa.Column('is_active', sa.Boolean(), server_default=sa.true(), nullable=False, comment="Si el agente está activo en el sistema"),
        sa.Column('availability_config_json', sa.JSON(), nullable=True, comment='Config JSON para horarios, etc.'),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), onupdate=sa.text('now()'), nullable=False),
        sa.PrimaryKeyConstraint('id', name=op.f('pk_human_agents'))
    )
    op.create_index(op.f('ix_human_agents_email'), 'human_agents', ['email'], unique=True)
    op.create_index(op.f('ix_human_agents_id'), 'human_agents', ['id'], unique=False)
    op.create_index(op.f('ix_human_agents_teams_id'), 'human_agents', ['teams_id'], unique=True)

    # Definir nombres de los ENUM Types para LLMModelConfig
    llm_provider_enum_name = 'llmproviderstype' # Mantener consistencia o ajustar al nombre que PostgreSQL le dé
    llm_model_type_enum_name = 'llmmodeltype'

    op.create_table('llm_model_configs',
        sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
        sa.Column('model_identifier', sa.String(length=255), nullable=False),
        sa.Column('display_name', sa.String(length=150), nullable=False),
        sa.Column('provider', postgresql.ENUM('GOOGLE', 'OPENAI', 'AZURE_OPENAI', 'ANTHROPIC', 'HUGGINGFACE_LOCAL', 'OLLAMA', 'CUSTOM', name=llm_provider_enum_name, create_type=True), nullable=False),
        sa.Column('model_type', postgresql.ENUM('CHAT_COMPLETION', 'TEXT_GENERATION', 'EMBEDDING', name=llm_model_type_enum_name, create_type=True), server_default='CHAT_COMPLETION', nullable=False),
        sa.Column('is_active', sa.Boolean(), server_default=sa.true(), nullable=False),
        sa.Column('api_key_env_var', sa.String(length=100), nullable=True),
        sa.Column('base_url', sa.String(length=512), nullable=True),
        sa.Column('default_temperature', sa.Float(), server_default='0.7', nullable=True),
        sa.Column('default_max_tokens', sa.Integer(), server_default='2048', nullable=True),
        sa.Column('supports_system_prompt', sa.Boolean(), server_default=sa.true(), nullable=False),
        sa.Column('config_json', sa.JSON(), nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), onupdate=sa.text('now()'), nullable=False),
        sa.PrimaryKeyConstraint('id', name=op.f('pk_llm_model_configs'))
    )
    op.create_index(op.f('ix_llm_model_configs_id'), 'llm_model_configs', ['id'], unique=False)
    op.create_index(op.f('ix_llm_model_configs_model_identifier'), 'llm_model_configs', ['model_identifier'], unique=True)
    op.create_index(op.f('ix_llm_model_configs_provider'), 'llm_model_configs', ['provider'], unique=False)

    op.create_table('human_agent_group_assignment_assoc',
        sa.Column('human_agent_id', sa.Integer(), nullable=False),
        sa.Column('human_agent_group_id', sa.Integer(), nullable=False),
        sa.ForeignKeyConstraint(['human_agent_group_id'], ['human_agent_groups.id'], name=op.f('fk_hag_assoc_group_id'), ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['human_agent_id'], ['human_agents.id'], name=op.f('fk_hag_assoc_human_agent_id'), ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('human_agent_id', 'human_agent_group_id', name=op.f('pk_human_agent_group_assignment_assoc')),
        comment='Tabla de asociación para asignar agentes humanos a grupos de agentes.'
    )

    op.create_table('virtual_agent_profiles',
        sa.Column('id', sa.Integer(), autoincrement=True, nullable=False),
        sa.Column('name', sa.String(length=150), nullable=False),
        sa.Column('description', sa.Text(), nullable=True),
        sa.Column('user_provided_goal_description', sa.Text(), nullable=True),
        sa.Column('system_prompt', sa.Text(), nullable=False),
        sa.Column('llm_model_config_id', sa.Integer(), nullable=False),
        sa.Column('temperature_override', sa.Float(), nullable=True),
        sa.Column('max_tokens_override', sa.Integer(), nullable=True),
        sa.Column('is_active', sa.Boolean(), server_default=sa.true(), nullable=False),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), onupdate=sa.text('now()'), nullable=False),
        sa.ForeignKeyConstraint(['llm_model_config_id'], ['llm_model_configs.id'], name=op.f('fk_vap_llm_model_config_id')),
        sa.PrimaryKeyConstraint('id', name=op.f('pk_virtual_agent_profiles')),
        sa.UniqueConstraint('name', name=op.f('uq_virtual_agent_profiles_name'))
    )
    op.create_index(op.f('ix_virtual_agent_profiles_id'), 'virtual_agent_profiles', ['id'], unique=False)


    # --- PASO 5: Eliminar otras tablas antiguas ---
    op.drop_index(op.f('ix_users_dni'), table_name='users', if_exists=True)
    op.drop_index(op.f('ix_users_email'), table_name='users', if_exists=True)
    op.drop_index(op.f('ix_users_id'), table_name='users', if_exists=True)
    op.drop_table('users', if_exists=True)
    
    op.drop_table('context_db_connection_assoc', if_exists=True)


    # --- PASO 6: Modificaciones a context_definitions ---
    op.add_column('context_definitions', sa.Column('default_llm_model_config_id', sa.Integer(), nullable=True))
    op.add_column('context_definitions', sa.Column('virtual_agent_profile_id', sa.Integer(), nullable=True))
    op.add_column('context_definitions', sa.Column('db_connection_config_id', sa.Integer(), nullable=True, comment='FK a db_connection_configs, si main_type es DATABASE_QUERY.'))
    
    # Crear explícitamente el NUEVO tipo ENUM para context_main_type ANTES de usarlo en ALTER COLUMN
    new_context_main_type_enum_name = 'context_main_type_enum_v2' # Nombre del NUEVO tipo ENUM en la BD
    new_context_main_type_values = ('DOCUMENTAL', 'DATABASE_QUERY', 'IMAGE_ANALYSIS')
    new_context_main_type_values_sql = ", ".join([f"'{val}'" for val in new_context_main_type_values])
    
    # Eliminar el tipo ENUM antiguo SI ES POSIBLE (si no hay otras columnas usándolo y si los datos se migrarán correctamente)
    # Esta parte es delicada. Es más seguro si la alteración de la columna se hace sin eliminar el tipo antiguo primero,
    # y luego se elimina el tipo antiguo si ya no es referenciado por ninguna columna.
    # op.execute(f"DROP TYPE IF EXISTS context_main_type_enum;") # Descomentar con MUCHO CUIDADO

    op.execute(f"CREATE TYPE {new_context_main_type_enum_name} AS ENUM({new_context_main_type_values_sql});")
    
    op.alter_column('context_definitions', 'main_type',
               existing_type=postgresql.ENUM('DOCUMENTAL', 'DATABASE_QUERY', name='context_main_type_enum', create_type=False), # Nombre del TIPO enum existente en BD
               type_=postgresql.ENUM(*new_context_main_type_values, name=new_context_main_type_enum_name, create_type=False), # Usa el NUEVO TIPO enum
               existing_nullable=False,
               postgresql_using=f'main_type::text::{new_context_main_type_enum_name}') # Castear al NUEVO TIPO
    
    # Si el tipo ENUM antiguo ('context_main_type_enum') ya no se usa después de esta alteración, se puede eliminar.
    # Pero es más seguro dejarlo por si downgrade lo necesita, o si el alter_column lo manejó bien.
    # Si tu modelo SAEnum tiene create_type=True para el nuevo enum, Alembic intenta crear el tipo.
    # Si tenía create_type=False para el antiguo (existing_type), no intenta eliminarlo.
    
    op.alter_column('context_definitions', 'processing_config',
               existing_type=postgresql.JSON(astext_type=sa.Text()), 
               comment='Configuración estructurada (JSON) específica del main_type.',
               existing_nullable=True)
               
    op.create_foreign_key(op.f('fk_context_def_default_llm_id'), 'context_definitions', 'llm_model_configs', ['default_llm_model_config_id'], ['id'])
    op.create_foreign_key(op.f('fk_context_def_vap_id'), 'context_definitions', 'virtual_agent_profiles', ['virtual_agent_profile_id'], ['id'])
    op.create_foreign_key(op.f('fk_context_def_db_conn_id'), 'context_definitions', 'db_connection_configs', ['db_connection_config_id'], ['id'])
    
    op.drop_column('context_definitions', 'default_llm_model', if_exists=True)

    # --- PASO 7: Recrear FK en user_role_association apuntando a la nueva tabla 'app_user' ---
    op.create_foreign_key(
        op.f('fk_user_role_association_app_user_id'), 
        'user_role_association', 'app_user', 
        ['app_user_id'], ['id'], 
        ondelete='CASCADE'
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### ADVERTENCIA: El downgrade es complejo y este es un ESBOZO. Debe ser probado cuidadosamente. ###
    
    # Revertir FK en user_role_association y recrear app_users
    op.drop_constraint(op.f('fk_user_role_association_app_user_id'), 'user_role_association', type_='foreignkey')
    op.drop_table('app_user') # Eliminar la nueva 'app_user'
    
    # Recrear la antigua tabla 'app_users' (Asegúrate que esta estructura es idéntica a la original)
    op.create_table('app_users',
        sa.Column('id', sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column('username_ad', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
        sa.Column('email', sa.VARCHAR(length=255), autoincrement=False, nullable=True),
        # ... resto de columnas de app_users como las tenías ...
        sa.PrimaryKeyConstraint('id', name='app_users_pkey') # o el nombre que tenía
    )
    # Recrear índices para app_users
    op.create_index('ix_app_users_username_ad', 'app_users', ['username_ad'], unique=True)
    op.create_index('ix_app_users_id', 'app_users', ['id'], unique=False)
    op.create_index('ix_app_users_email', 'app_users', ['email'], unique=True)

    # Recrear la FK original de user_role_association apuntando a app_users
    op.create_foreign_key('user_role_association_app_user_id_fkey', # Nombre original si se conoce
                          'user_role_association', 'app_users', 
                          ['app_user_id'], ['id'], ondelete='CASCADE')

    # Revertir context_definitions
    op.add_column('context_definitions', sa.Column('default_llm_model', sa.VARCHAR(length=100), autoincrement=False, nullable=True))
    op.drop_constraint(op.f('fk_context_def_db_conn_id'), 'context_definitions', type_='foreignkey')
    op.drop_constraint(op.f('fk_context_def_vap_id'), 'context_definitions', type_='foreignkey')
    op.drop_constraint(op.f('fk_context_def_default_llm_id'), 'context_definitions', type_='foreignkey')
    
    # Revertir ENUM main_type
    old_enum_name_from_v2 = 'context_main_type_enum' # El nombre que tenía antes de ser _v2
    new_enum_name_to_drop = 'context_main_type_enum_v2'
    old_enum_values_original = ('DOCUMENTAL', 'DATABASE_QUERY')

    # Esto es riesgoso si hay datos. Un downgrade real de ENUMs puede requerir manipulación de datos.
    op.alter_column('context_definitions', 'main_type',
               existing_type=postgresql.ENUM(*new_enum_values, name=new_enum_name_to_drop, create_type=False),
               type_=postgresql.ENUM(*old_enum_values_original, name=old_enum_name_from_v2, create_type=True), # Recrea el tipo antiguo si no existe
               existing_nullable=False,
               postgresql_using=f'main_type::text::{old_enum_name_from_v2}')
    op.execute(f"DROP TYPE IF EXISTS {new_enum_name_to_drop};") # Eliminar el tipo v2


    op.drop_column('context_definitions', 'db_connection_config_id')
    op.drop_column('context_definitions', 'virtual_agent_profile_id')
    op.drop_column('context_definitions', 'default_llm_model_config_id')
    
    # Revertir chat_message_history_v2
    op.drop_index(op.f('ix_chat_message_history_v2_session_id'), table_name='chat_message_history_v2')
    op.alter_column('chat_message_history_v2', 'message',
               existing_type=sa.JSON(), type_=sa.TEXT(), nullable=True) # Volver a TEXT
    op.alter_column('chat_message_history_v2', 'session_id',
               existing_type=sa.String(length=255), type_=sa.TEXT(), nullable=True)

    # Recrear tablas eliminadas (context_db_connection_assoc, users)
    op.create_table('context_db_connection_assoc',
        # ... (definición completa como estaba en tu script de Alembic original)
        sa.Column('context_definition_id', sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column('db_connection_config_id', sa.INTEGER(), autoincrement=False, nullable=False),
        sa.ForeignKeyConstraint(['context_definition_id'], ['context_definitions.id'], name='context_db_connection_assoc_context_definition_id_fkey', ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['db_connection_config_id'], ['db_connection_configs.id'], name='context_db_connection_assoc_db_connection_config_id_fkey', ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('context_definition_id', 'db_connection_config_id', name='context_db_connection_assoc_pkey')
    )
    op.create_table('users',
        # ... (definición completa como estaba en tu script de Alembic original)
        sa.Column('id', sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column('dni', sa.VARCHAR(length=20), autoincrement=False, nullable=False),
        sa.Column('email', sa.VARCHAR(length=100), autoincrement=False, nullable=True),
        sa.Column('full_name', sa.VARCHAR(length=100), autoincrement=False, nullable=True),
        sa.Column('role', sa.VARCHAR(length=50), autoincrement=False, nullable=False),
        sa.Column('is_active', sa.BOOLEAN(), autoincrement=False, nullable=True),
        sa.PrimaryKeyConstraint('id', name='users_pkey')
    )
    op.create_index(op.f('ix_users_id'), 'users', ['id'], unique=False)
    op.create_index(op.f('ix_users_email'), 'users', ['email'], unique=True)
    op.create_index(op.f('ix_users_dni'), 'users', ['dni'], unique=True)
    
    # Eliminar las nuevas tablas y sus índices (en orden inverso a la creación)
    op.drop_index(op.f('ix_virtual_agent_profiles_name'), table_name='virtual_agent_profiles', if_exists=True) # if_exists si no estaba en create_table
    op.drop_index(op.f('ix_virtual_agent_profiles_id'), table_name='virtual_agent_profiles')
    op.drop_table('virtual_agent_profiles')
    
    op.drop_table('human_agent_group_assignment_assoc')
    
    op.drop_index(op.f('ix_llm_model_configs_provider'), table_name='llm_model_configs')
    op.drop_index(op.f('ix_llm_model_configs_model_identifier'), table_name='llm_model_configs')
    op.drop_index(op.f('ix_llm_model_configs_id'), table_name='llm_model_configs')
    op.drop_table('llm_model_configs') # Esto eliminará los ENUMs asociados si son 'inline' o si SQLAlchemy los maneja bien
    # Es posible que necesites `op.execute(f"DROP TYPE IF EXISTS {llm_provider_enum_name};")` y para el model_type también.

    op.drop_index(op.f('ix_human_agents_teams_id'), table_name='human_agents')
    op.drop_index(op.f('ix_human_agents_id'), table_name='human_agents')
    op.drop_index(op.f('ix_human_agents_email'), table_name='human_agents')
    op.drop_table('human_agents')
    
    op.drop_index(op.f('ix_human_agent_groups_id'), table_name='human_agent_groups')
    op.drop_table('human_agent_groups')
    
    # ### end Alembic commands ###