MANUAL
Manual Detallado de Uso de APIs Generadas (Esbozo)
Este sería un documento para los desarrolladores que quieran consumir tu API de chatbot.
API del Chatbot - Manual de Integración
1. Autenticación
Endpoint: POST /api/v1/chat/
Método de Autenticación: API Key.
Cabecera Requerida: X-API-Key: TU_API_KEY_GENERADO_POR_ADMIN
Obtención de API Key: Las API Keys son generadas por el administrador del sistema Chatbot a través del panel de administración (ver "APIs de Administración"). Cada API Key está asociada a una aplicación cliente específica y puede tener contextos de conocimiento predeterminados y permisos.
2. Endpoint de Chat Principal
URL: POST /api/v1/chat/
Descripción: Envía un mensaje de usuario y obtiene una respuesta del chatbot. El chatbot utiliza RAG, historial de conversación (asociado al DNI) y puede consultar bases de datos configuradas (Text-to-SQL) según los permisos del API Key y la intención de la pregunta.
Request Body (JSON):
{
  "dni": "string (requerido) - DNI del usuario final para identificar su historial de conversación y aplicar permisos de rol.",
  "message": "string (requerido) - Mensaje/pregunta del usuario."
}
Use code with caution.
Json
Response Body (JSON - Éxito 200 OK):
{
  "dni": "string - DNI del usuario.",
  "original_message": "string - Mensaje original del usuario.",
  "bot_response": "string - Respuesta generada por el chatbot."
}
Use code with caution.
Json
Posibles Errores HTTP:
403 Forbidden:
"No se proporcionó API Key en la cabecera."
"API Key inválida."
"API Key inactiva."
422 Unprocessable Entity: Si el dni o message faltan en el request body.
500 Internal Server Error:
"Error interno del servidor: modelo de embedding no disponible."
"Error al procesar embedding de la pregunta."
"Error procesando su solicitud con IA." (Error genérico del RAG o Text-to-SQL).
"No pude preparar el acceso a BD: [detalle del error de configuración de SQLDatabase]."
"El chatbot encontró un problema técnico al procesar la solicitud."
503 Service Unavailable: "API Key de Gemini no configurada." (si el admin del chatbot no puso la key del LLM).
3. APIs de Administración (Para el Panel de Control del Chatbot)
Estas APIs son para que los administradores configuren el sistema. Requieren su propia autenticación de administrador (pendiente de definir, idealmente con MFA).
Use code with caution.
3.1. Gestión de Clientes API (/api/v1/admin/api_clients/)
POST /: Crea un nuevo ApiClient (para una app que consumirá el chat). Devuelve la api_key_plain UNA SOLA VEZ.
Body: { "name": "Cliente App X", "description": "...", "settings": {"allowed_context_names": ["ContextoA", "ContextoB"]} }
GET /: Lista todos los ApiClients (no devuelve la key).
GET /{client_id}: Obtiene detalles de un ApiClient (no devuelve la key).
PUT /{client_id}: Actualiza un ApiClient (ej. sus settings).
POST /{client_id}/regenerate_key: Genera una nueva API Key para este cliente. Devuelve la nueva key.
DELETE /{client_id}: Elimina un ApiClient.
3.2. Gestión de Conexiones a Bases de Datos (/api/v1/admin/db_connections/)
POST /: Crea una nueva configuración de conexión a BD (SQL Server, Postgres, etc.). Contraseñas se guardan encriptadas.
Body: { "name": "DW SQL", "db_type": "SQLSERVER", "host": "...", "port": ..., "database_name": "...", "username": "...", "password": "...", "extra_params": {"driver": "..."} }
GET /: Lista todas las configuraciones.
GET /{conn_id}: Detalles de una conexión.
PUT /{conn_id}: Actualiza una conexión.
DELETE /{conn_id}: Elimina.
3.3. Gestión de Orígenes de Documentos (/api/v1/admin/doc_sources/)
POST /: Crea un nuevo origen de documentos. Credenciales se guardan encriptadas.
Body: { "name": "Manuales Carpeta", "source_type": "LOCAL_FOLDER", "path_or_config": {"path": "/srv/docs"}, "credentials_info": null }
Body (S3): { "name": "Bucket S3 Investigación", "source_type": "S3_BUCKET", "path_or_config": {"bucket_name": "...", "prefix": "..."}, "credentials_info": {"aws_access_key_id":"...", ...} }
GET /: Lista orígenes.
GET /{source_id}: Detalles.
PUT /{source_id}: Actualiza.
DELETE /{source_id}: Elimina.
3.4. Gestión de Definiciones de Contexto (/api/v1/admin/context_definitions/)
POST /: Crea una nueva ContextDefinition.
Body: { "name": "Contexto X", "main_type": "DOCUMENTAL" | "DATABASE_QUERY", "processing_config": { ... }, "document_source_ids": [1,2], "db_connection_ids": [1] }
El processing_config contendrá chunk_size para documental, o dictionary_table_query y sql_select_policy para DATABASE_QUERY.
GET /: Lista definiciones de contexto con sus orígenes/conexiones asociados.
GET /{context_id}: Detalles.
PUT /{context_id}: Actualiza una definición (incluyendo sus processing_config o las listas de IDs de relaciones).
DELETE /{context_id}: Elimina.
4. Qué Falta por Hacer (Resumen de Funcionalidades Pendientes Clave):
Completar Text-to-SQL:
Resolver el problema actual de por qué SQLDatabase.get_table_info() no devuelve el DDL de las tablas que SÍ fueron reflejadas explícitamente en el MetaData que se le pasó.
Asegurar que el prompt del LLM para generar SQL reciba el DDL correcto.
Implementar la validación robusta del SQL generado según sql_select_policy.
Filtrado "OR" para Múltiples Contextos en RAG Documental: Investigar la mejor forma de hacerlo con PGVector.as_retriever(filter=...) o implementar la lógica de "múltiples retrievers y unir resultados".
Ingesta para Otros Tipos de DocumentSourceConfig: Implementar la lógica en ingest_document.py para S3, Azure Blob, URLs web, etc., usando los DocumentLoaders de Langchain y manejando las credentials_info_encrypted.
Roles de Usuario y Permisos de Contexto por Rol:
Modelo UserRole y RoleContextPermission.
Modificar chat_api_endpoints.py para que la lista de contextos permitidos sea una COMBINACIÓN de los permisos del ApiClient Y los del rol del User.
Interfaz de Administración (Frontend): Para consumir estas APIs de admin.
MFA para Admin: Implementar autenticación multifactor para los endpoints de admin.
Query Cache (Redis).
Feedback Like/Dislike.
Human Handoff (opcional).
Optimización de Prompts.
Pruebas Unitarias y de Integración.
Despliegue (AWS Linux).